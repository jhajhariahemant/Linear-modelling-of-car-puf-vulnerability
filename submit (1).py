import numpy as np
import sklearn
from sklearn.svm import LinearSVC
from scipy.linalg import khatri_rao
from sklearn.linear_model import LogisticRegression,RidgeClassifier
# from math import inf


# You are allowed to import any submodules of sklearn that learn linear models e.g. sklearn.svm etc
# You are not allowed to use other libraries such as keras, tensorflow etc
# You are not allowed to use any scipy routine other than khatri_rao

# SUBMIT YOUR CODE AS A SINGLE PYTHON (.PY) FILE INSIDE A ZIP ARCHIVE
# THE NAME OF THE PYTHON FILE MUST BE submit.py

# DO NOT CHANGE THE NAME OF THE METHODS my_fit, my_map etc BELOW
# THESE WILL BE INVOKED BY THE EVALUATION SCRIPT. CHANGING THESE NAMES WILL CAUSE EVALUATION FAILURE

# You may define any new functions, variables, classes here
# For example, functions to calculate next coordinate or step length

################################
# Non Editable Region Starting #
################################
def my_fit( X_train, y_train ):
################################
#  Non Editable Region Ending  #
################################
	# logreg = LogisticRegression(random_state=42)
	clf = LogisticRegression(C=10, penalty='l2', dual=False, tol=0.1, intercept_scaling=0.5, random_state=42)
	features=my_map(X_train)
	# logreg.fit(features,y_train)
	# ridge_classifier = RidgeClassifier(alpha=0.5)  # Adjust alpha as needed

# Train the model
	# ridge_classifier.fit(features, y_train)

	# Use this method to train your model using training CRPs
	# X_train has 32 columns containing the challeenge bits
	# y_train contains the responses
	
	# THE RETURNED MODEL SHOULD BE A SINGLE VECTOR AND A BIAS TERM
	# If you do not wish to use a bias term, set it to 0
	# w = logreg.coef_
	# b = logreg.intercept_
	clf.fit(features,y_train)
	w=clf.coef_
	b=clf.intercept_
	# w=ridge_classifier.coef_
	# b=ridge_classifier.intercept_
	
	return w[0], b

def C_to_X( c_vector):
	x=list(c_vector)
	for i in range(32):
		x[i]=1-2*x[i]
	# x=np.empty(32)
	# x[31] = X[31]
	for i in range(30,-1,-1):
		x[i]=x[i+1]*x[i]
	feat=[]
	# print(feat)
	
	for i in range(32):
		feat.append(x[i])
	for i in range(32):
		for j in range(i+1,32):
			feat.append(x[i]*x[j])
	return np.array(feat)


################################
# Non Editable Region Starting #
################################
def my_map( X ):
	feat=[]
	for x in X:
		feat.append(C_to_X(x))
	return np.array(feat)
################################
#  Non Editable Region Ending  #
################################

	# Use this method to create features.
	# It is likely that my_fit will internally call my_map to create features for train points